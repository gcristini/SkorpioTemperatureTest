/***************************************************************************//**
* \file     ADC_Temp.c
* \version  3.10
*
* \brief
* Provides the source code to the API for the ADC_Temp Component.
*
********************************************************************************
* \copyright
* (c) 2015-2018, Cypress Semiconductor Corporation. All rights reserved.
* This software, including source code, documentation and related
* materials ("Software"), is owned by Cypress Semiconductor
* Corporation ("Cypress") and is protected by and subject to worldwide
* patent protection (United States and foreign), United States copyright
* laws and international treaty provisions. Therefore, you may use this
* Software only as provided in the license agreement accompanying the
* software package from which you obtained this Software ("EULA").
* If no EULA applies, Cypress hereby grants you a personal, nonexclusive,
* non-transferable license to copy, modify, and compile the
* Software source code solely for use in connection with Cypress's
* integrated circuit products. Any reproduction, modification, translation,
* compilation, or representation of this Software except as specified
* above is prohibited without the express written permission of Cypress.
* Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO
* WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING,
* BUT NOT LIMITED TO, NONINFRINGEMENT, IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
* PARTICULAR PURPOSE. Cypress reserves the right to make
* changes to the Software without notice. Cypress does not assume any
* liability arising out of the application or use of the Software or any
* product or circuit described in the Software. Cypress does not
* authorize its products for use in any products where a malfunction or
* failure of the Cypress product may reasonably be expected to result in
* significant property damage, injury or death ("High Risk Product"). By
* including Cypress's product in a High Risk Product, the manufacturer
* of such system or application assumes all risk of such use and in doing
* so agrees to indemnify Cypress against all liability.
*******************************************************************************/
#include "ADC_Temp.h"

static void ADC_Temp_SetDFTControl(const ADC_Temp_CONFIG_STRUCT *config);
static int32 ADC_Temp_IsChannelSigned(uint32 chan);
#if(ADC_Temp_ANY_CONFIG_USES_FILTER != 0u)
static void ADC_Temp_SetupComparatorTrim(void);
static void ADC_Temp_UndoComparatorTrimSetup(void);
static uint32 ADC_Temp_RaiseOpampTrimToCrossing(uint32 startTrim);
static uint32 ADC_Temp_LowerOpampTrimToCrossing(uint32 startTrim);
static uint32 ADC_Temp_RaiseAgndTrimToCrossing(uint32 startTrim);
static uint32 ADC_Temp_LowerAgndTrimToCrossing(uint32 startTrim);
static uint32 ADC_Temp_SetOpampAndAgndTrim(uint32 opampTrim, uint32 agndTrim);
static uint32 ADC_Temp_SetOpampTrim(uint32 opampTrim);
static uint32 ADC_Temp_SetAgndTrim(uint32 agndTrim);
static uint32 ADC_Temp_IncOpampTrim(uint32 trim);
static uint32 ADC_Temp_DecOpampTrim(uint32 trim);
static uint32 ADC_Temp_IncAgndTrim(uint32 trim);
static uint32 ADC_Temp_DecAgndTrim(uint32 trim);
static uint32 ADC_Temp_GetCompStatus(void);
#define OFFSET_SAMPLES (30)
#endif

uint8 ADC_Temp_initVar = 0u;

uint8 ADC_Temp_selected = 0u; /* 0 if no configuration selected. 1 otherwise. */
volatile int16 ADC_Temp_offset[ADC_Temp_TOTAL_CHANNELS_NUM];
volatile int32 ADC_Temp_countsPer10Volt[ADC_Temp_TOTAL_CHANNELS_NUM];

static uint32 ADC_Temp_currentConfig = 0u; /* Currently active configuration */

/*******************************************************************************
* Local data allocation
*******************************************************************************/
/* Channels configuration generated by customiser */
static const uint32 CYCODE ADC_Temp_channelsConfig[] = { 0x00000000UL,  };

/* Filter init */
#if(ADC_Temp_ANY_CONFIG_USES_FILTER != 0u)
    #if (0u != ADC_Temp_CFG0_FILTER_PRESENT)
        #define ADC_Temp_CFG0_UABH_A_FILTER_INITPAIRSSIZE (19u)
        const static CyUAB_reg_pair ADC_Temp_CFG0_UABH_A_FILTER_initPairs[ADC_Temp_CFG0_UABH_A_FILTER_INITPAIRSSIZE] =
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_Temp_UABH_A_OA_CTRL_PTR        , ((uint32)ADC_Temp_UABH_A_DEFAULT_OA_CTRL)}
            ,{ADC_Temp_UABH_A_SW_STATIC_PTR      , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_STATIC)}
            ,{ADC_Temp_UABH_A_SW_MODBIT_SRC_PTR  , ((uint32)ADC_Temp_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{ADC_Temp_UABH_A_SRAM_CTRL_PTR      , ((uint32)ADC_Temp_UABH_A_INVAR_SRAM_CTRL)}
            ,{ADC_Temp_UABH_A_STARTUP_DELAY_PTR  , ((uint32)ADC_Temp_CFG0_UABH_A_STARTUP_DELAY)}
            ,{ADC_Temp_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_Temp_UABH_A_SW_CA_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_CA_IN1)}
            ,{ADC_Temp_UABH_A_SW_OTHER_PTR       , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_OTHER)}

            #if (ADC_Temp_CFG0_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{ADC_Temp_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG0_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_CFG0_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{ADC_Temp_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_CFG0_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{ADC_Temp_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_CFG0_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{ADC_Temp_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_CFG0_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{ADC_Temp_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG0_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_Temp_CFG0_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{ADC_Temp_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_Temp_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_Temp_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{ADC_Temp_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG0_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_CFG0_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_Temp_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG0_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (ADC_Temp_CFG0_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q) */
        };

        #define ADC_Temp_CFG0_UABH_B_FILTER_INITPAIRSSIZE (19u)
        const static CyUAB_reg_pair ADC_Temp_CFG0_UABH_B_FILTER_initPairs[ADC_Temp_CFG0_UABH_B_FILTER_INITPAIRSSIZE] =
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_Temp_UABH_B_OA_CTRL_PTR        , ((uint32)ADC_Temp_UABH_B_DEFAULT_OA_CTRL)}
            ,{ADC_Temp_UABH_B_SW_STATIC_PTR      , ((uint32)ADC_Temp_UABH_B_DEFAULT_SW_STATIC)}
            ,{ADC_Temp_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)ADC_Temp_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{ADC_Temp_UABH_B_SRAM_CTRL_PTR      , ((uint32)ADC_Temp_UABH_B_INVAR_SRAM_CTRL)}
            ,{ADC_Temp_UABH_B_STARTUP_DELAY_PTR  , ((uint32)ADC_Temp_CFG0_UABH_B_STARTUP_DELAY)}
            ,{ADC_Temp_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)ADC_Temp_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_Temp_UABH_B_SW_OTHER_PTR  , ((uint32)ADC_Temp_UABH_B_DEFAULT_SW_OTHER)}

            #if (ADC_Temp_CFG0_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q)
                        /* Filter-invariant registers */
                ,{ADC_Temp_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{ADC_Temp_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{ADC_Temp_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{ADC_Temp_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{ADC_Temp_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG0_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_CFG0_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{ADC_Temp_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG0_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_Temp_CFG0_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{ADC_Temp_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{ADC_Temp_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_Temp_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_Temp_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG0_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_CFG0_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_Temp_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_CFG0_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{ADC_Temp_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG0_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (ADC_Temp_CFG0_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q) */
        };

        const static CyUAB_config ADC_Temp_CFG0_UABH_A_FILTER_config = {
            ADC_Temp_UABH_A_waveConfig,
            (CyUAB_reg_pair*) ADC_Temp_CFG0_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(ADC_Temp_UABH_A_PARAM_REF_TIED,ADC_Temp_UABH_A_PARAM_AGND_TIED,
                ADC_Temp_UABH_A_PARAM_SW_CC,ADC_Temp_UABH_A_PARAM_SW_BB,ADC_Temp_UABH_A_PARAM_SW_AA),
            ADC_Temp_UABH_A_NUM_STEPS,
            (uint8)(ADC_Temp_UABH_A_ELEMENT_COUNT(ADC_Temp_CFG0_UABH_A_FILTER_initPairs))
        };

        const static CyUAB_config ADC_Temp_CFG0_UABH_B_FILTER_config = {
        ADC_Temp_UABH_B_waveConfig,
        (CyUAB_reg_pair*) ADC_Temp_CFG0_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(ADC_Temp_UABH_B_PARAM_REF_TIED,ADC_Temp_UABH_B_PARAM_AGND_TIED,
            ADC_Temp_UABH_B_PARAM_SW_CC,ADC_Temp_UABH_B_PARAM_SW_BB,ADC_Temp_UABH_B_PARAM_SW_AA),
        ADC_Temp_UABH_B_NUM_STEPS,
        (uint8)(ADC_Temp_UABH_B_ELEMENT_COUNT(ADC_Temp_CFG0_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != ADC_Temp_CFG0_FILTER_PRESENT) */
    #if (0u != ADC_Temp_CFG1_FILTER_PRESENT)
        #define ADC_Temp_CFG1_UABH_A_FILTER_INITPAIRSSIZE (19u)
        const static CyUAB_reg_pair ADC_Temp_CFG1_UABH_A_FILTER_initPairs[ADC_Temp_CFG1_UABH_A_FILTER_INITPAIRSSIZE] =
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_Temp_UABH_A_OA_CTRL_PTR        , ((uint32)ADC_Temp_UABH_A_DEFAULT_OA_CTRL)}
            ,{ADC_Temp_UABH_A_SW_STATIC_PTR      , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_STATIC)}
            ,{ADC_Temp_UABH_A_SW_MODBIT_SRC_PTR  , ((uint32)ADC_Temp_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{ADC_Temp_UABH_A_SRAM_CTRL_PTR      , ((uint32)ADC_Temp_UABH_A_INVAR_SRAM_CTRL)}
            ,{ADC_Temp_UABH_A_STARTUP_DELAY_PTR  , ((uint32)ADC_Temp_CFG1_UABH_A_STARTUP_DELAY)}
            ,{ADC_Temp_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_Temp_UABH_A_SW_CA_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_CA_IN1)}
            ,{ADC_Temp_UABH_A_SW_OTHER_PTR       , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_OTHER)}

            #if (ADC_Temp_CFG1_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{ADC_Temp_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG1_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_CFG1_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{ADC_Temp_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_CFG1_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{ADC_Temp_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_CFG1_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{ADC_Temp_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_CFG1_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{ADC_Temp_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG1_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_Temp_CFG1_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{ADC_Temp_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_Temp_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_Temp_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{ADC_Temp_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG1_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_CFG1_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_Temp_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG1_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (ADC_Temp_CFG1_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q) */
        };

        #define ADC_Temp_CFG1_UABH_B_FILTER_INITPAIRSSIZE (19u)
        const static CyUAB_reg_pair ADC_Temp_CFG1_UABH_B_FILTER_initPairs[ADC_Temp_CFG1_UABH_B_FILTER_INITPAIRSSIZE] =
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_Temp_UABH_B_OA_CTRL_PTR        , ((uint32)ADC_Temp_UABH_B_DEFAULT_OA_CTRL)}
            ,{ADC_Temp_UABH_B_SW_STATIC_PTR      , ((uint32)ADC_Temp_UABH_B_DEFAULT_SW_STATIC)}
            ,{ADC_Temp_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)ADC_Temp_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{ADC_Temp_UABH_B_SRAM_CTRL_PTR      , ((uint32)ADC_Temp_UABH_B_INVAR_SRAM_CTRL)}
            ,{ADC_Temp_UABH_B_STARTUP_DELAY_PTR  , ((uint32)ADC_Temp_CFG1_UABH_B_STARTUP_DELAY)}
            ,{ADC_Temp_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)ADC_Temp_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_Temp_UABH_B_SW_OTHER_PTR       , ((uint32)ADC_Temp_UABH_B_DEFAULT_SW_OTHER)}

            #if (ADC_Temp_CFG1_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q)
                        /* Filter-invariant registers */
                ,{ADC_Temp_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{ADC_Temp_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{ADC_Temp_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{ADC_Temp_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{ADC_Temp_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG1_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_CFG1_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{ADC_Temp_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG1_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_Temp_CFG1_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{ADC_Temp_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{ADC_Temp_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_Temp_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_Temp_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG1_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_CFG1_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_Temp_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_CFG1_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{ADC_Temp_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG1_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (ADC_Temp_CFG1_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q) */
        };

        const static CyUAB_config ADC_Temp_CFG1_UABH_A_FILTER_config = {
            ADC_Temp_UABH_A_waveConfig,
            (CyUAB_reg_pair*) ADC_Temp_CFG1_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(ADC_Temp_UABH_A_PARAM_REF_TIED,ADC_Temp_UABH_A_PARAM_AGND_TIED,
                ADC_Temp_UABH_A_PARAM_SW_CC,ADC_Temp_UABH_A_PARAM_SW_BB,ADC_Temp_UABH_A_PARAM_SW_AA),
            ADC_Temp_UABH_A_NUM_STEPS,
            (uint8)(ADC_Temp_UABH_A_ELEMENT_COUNT(ADC_Temp_CFG1_UABH_A_FILTER_initPairs))
        };

        const static CyUAB_config ADC_Temp_CFG1_UABH_B_FILTER_config = {
        ADC_Temp_UABH_B_waveConfig,
        (CyUAB_reg_pair*) ADC_Temp_CFG1_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(ADC_Temp_UABH_B_PARAM_REF_TIED,ADC_Temp_UABH_B_PARAM_AGND_TIED,
            ADC_Temp_UABH_B_PARAM_SW_CC,ADC_Temp_UABH_B_PARAM_SW_BB,ADC_Temp_UABH_B_PARAM_SW_AA),
        ADC_Temp_UABH_B_NUM_STEPS,
        (uint8)(ADC_Temp_UABH_B_ELEMENT_COUNT(ADC_Temp_CFG1_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != ADC_Temp_CFG1_FILTER_PRESENT) */
    #if (0u != ADC_Temp_CFG2_FILTER_PRESENT)
        #define ADC_Temp_CFG2_UABH_A_FILTER_INITPAIRSSIZE (19u)
        const static CyUAB_reg_pair ADC_Temp_CFG2_UABH_A_FILTER_initPairs[ADC_Temp_CFG2_UABH_A_FILTER_INITPAIRSSIZE] =
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_Temp_UABH_A_OA_CTRL_PTR        , ((uint32)ADC_Temp_UABH_A_DEFAULT_OA_CTRL)}
            ,{ADC_Temp_UABH_A_SW_STATIC_PTR      , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_STATIC)}
            ,{ADC_Temp_UABH_A_SW_MODBIT_SRC_PTR  , ((uint32)ADC_Temp_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{ADC_Temp_UABH_A_SRAM_CTRL_PTR      , ((uint32)ADC_Temp_UABH_A_INVAR_SRAM_CTRL)}
            ,{ADC_Temp_UABH_A_STARTUP_DELAY_PTR  , ((uint32)ADC_Temp_CFG2_UABH_A_STARTUP_DELAY)}
            ,{ADC_Temp_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_Temp_UABH_A_SW_CA_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_CA_IN1)}
            ,{ADC_Temp_UABH_A_SW_OTHER_PTR       , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_OTHER)}

            #if (ADC_Temp_CFG2_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{ADC_Temp_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG2_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_CFG2_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{ADC_Temp_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_CFG2_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{ADC_Temp_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_CFG2_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{ADC_Temp_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_CFG2_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{ADC_Temp_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG2_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_Temp_CFG2_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{ADC_Temp_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_Temp_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_Temp_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{ADC_Temp_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG2_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_CFG2_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_Temp_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG2_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (ADC_Temp_CFG2_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q) */
        };

        #define ADC_Temp_CFG2_UABH_B_FILTER_INITPAIRSSIZE (19u)
        const static CyUAB_reg_pair ADC_Temp_CFG2_UABH_B_FILTER_initPairs[ADC_Temp_CFG2_UABH_B_FILTER_INITPAIRSSIZE] =
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_Temp_UABH_B_OA_CTRL_PTR        , ((uint32)ADC_Temp_UABH_B_DEFAULT_OA_CTRL)}
            ,{ADC_Temp_UABH_B_SW_STATIC_PTR      , ((uint32)ADC_Temp_UABH_B_DEFAULT_SW_STATIC)}
            ,{ADC_Temp_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)ADC_Temp_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{ADC_Temp_UABH_B_SRAM_CTRL_PTR      , ((uint32)ADC_Temp_UABH_B_INVAR_SRAM_CTRL)}
            ,{ADC_Temp_UABH_B_STARTUP_DELAY_PTR  , ((uint32)ADC_Temp_CFG2_UABH_B_STARTUP_DELAY)}
            ,{ADC_Temp_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)ADC_Temp_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_Temp_UABH_B_SW_OTHER_PTR       , ((uint32)ADC_Temp_UABH_B_DEFAULT_SW_OTHER)}

            #if (ADC_Temp_CFG2_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q)
                        /* Filter-invariant registers */
                ,{ADC_Temp_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{ADC_Temp_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{ADC_Temp_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{ADC_Temp_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{ADC_Temp_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG2_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_CFG2_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{ADC_Temp_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG2_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_Temp_CFG2_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{ADC_Temp_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{ADC_Temp_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_Temp_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_Temp_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG2_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_CFG2_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_Temp_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_CFG2_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{ADC_Temp_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG2_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (ADC_Temp_CFG2_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q) */
        };

        const static CyUAB_config ADC_Temp_CFG2_UABH_A_FILTER_config = {
            ADC_Temp_UABH_A_waveConfig,
            (CyUAB_reg_pair*) ADC_Temp_CFG2_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(ADC_Temp_UABH_A_PARAM_REF_TIED,ADC_Temp_UABH_A_PARAM_AGND_TIED,
                ADC_Temp_UABH_A_PARAM_SW_CC,ADC_Temp_UABH_A_PARAM_SW_BB,ADC_Temp_UABH_A_PARAM_SW_AA),
            ADC_Temp_UABH_A_NUM_STEPS,
            (uint8)(ADC_Temp_UABH_A_ELEMENT_COUNT(ADC_Temp_CFG2_UABH_A_FILTER_initPairs))
        };

        const static CyUAB_config ADC_Temp_CFG2_UABH_B_FILTER_config = {
        ADC_Temp_UABH_B_waveConfig,
        (CyUAB_reg_pair*) ADC_Temp_CFG2_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(ADC_Temp_UABH_B_PARAM_REF_TIED,ADC_Temp_UABH_B_PARAM_AGND_TIED,
            ADC_Temp_UABH_B_PARAM_SW_CC,ADC_Temp_UABH_B_PARAM_SW_BB,ADC_Temp_UABH_B_PARAM_SW_AA),
        ADC_Temp_UABH_B_NUM_STEPS,
        (uint8)(ADC_Temp_UABH_B_ELEMENT_COUNT(ADC_Temp_CFG2_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != ADC_Temp_CFG2_FILTER_PRESENT) */
    #if (0u != ADC_Temp_CFG3_FILTER_PRESENT)
        #define ADC_Temp_CFG3_UABH_A_FILTER_INITPAIRSSIZE (19u)
        const static CyUAB_reg_pair ADC_Temp_CFG3_UABH_A_FILTER_initPairs[ADC_Temp_CFG3_UABH_A_FILTER_INITPAIRSSIZE] =
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_Temp_UABH_A_OA_CTRL_PTR        , ((uint32)ADC_Temp_UABH_A_DEFAULT_OA_CTRL)}
            ,{ADC_Temp_UABH_A_SW_STATIC_PTR      , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_STATIC)}
            ,{ADC_Temp_UABH_A_SW_MODBIT_SRC_PTR  , ((uint32)ADC_Temp_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{ADC_Temp_UABH_A_SRAM_CTRL_PTR      , ((uint32)ADC_Temp_UABH_A_INVAR_SRAM_CTRL)}
            ,{ADC_Temp_UABH_A_STARTUP_DELAY_PTR  , ((uint32)ADC_Temp_CFG3_UABH_A_STARTUP_DELAY)}
            ,{ADC_Temp_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_Temp_UABH_A_SW_CA_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_CA_IN1)}
            ,{ADC_Temp_UABH_A_SW_OTHER_PTR       , ((uint32)ADC_Temp_UABH_A_DEFAULT_SW_OTHER)}

            #if (ADC_Temp_CFG3_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{ADC_Temp_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG3_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_CFG3_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{ADC_Temp_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_CFG3_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{ADC_Temp_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_CFG3_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{ADC_Temp_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_CFG3_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{ADC_Temp_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG3_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_Temp_CFG3_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{ADC_Temp_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_Temp_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_Temp_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{ADC_Temp_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG3_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_CFG3_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_Temp_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG3_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (ADC_Temp_CFG3_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q) */
        };

        #define ADC_Temp_CFG3_UABH_B_FILTER_INITPAIRSSIZE (19u)
        const static CyUAB_reg_pair ADC_Temp_CFG3_UABH_B_FILTER_initPairs[ADC_Temp_CFG3_UABH_B_FILTER_INITPAIRSSIZE] =
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_Temp_UABH_B_OA_CTRL_PTR        , ((uint32)ADC_Temp_UABH_B_DEFAULT_OA_CTRL)}
            ,{ADC_Temp_UABH_B_SW_STATIC_PTR      , ((uint32)ADC_Temp_UABH_B_DEFAULT_SW_STATIC)}
            ,{ADC_Temp_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)ADC_Temp_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{ADC_Temp_UABH_B_SRAM_CTRL_PTR      , ((uint32)ADC_Temp_UABH_B_INVAR_SRAM_CTRL)}
            ,{ADC_Temp_UABH_B_STARTUP_DELAY_PTR  , ((uint32)ADC_Temp_CFG3_UABH_B_STARTUP_DELAY)}
            ,{ADC_Temp_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)ADC_Temp_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_Temp_UABH_B_SW_OTHER_PTR       , ((uint32)ADC_Temp_UABH_B_DEFAULT_SW_OTHER)}

            #if (ADC_Temp_CFG3_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q)
                        /* Filter-invariant registers */
                ,{ADC_Temp_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{ADC_Temp_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{ADC_Temp_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{ADC_Temp_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{ADC_Temp_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_B_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG3_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_CFG3_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{ADC_Temp_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG3_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_Temp_CFG3_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{ADC_Temp_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_Temp_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{ADC_Temp_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_Temp_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_Temp_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_Temp_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_Temp_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_Temp_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_Temp_UABH_B_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_Temp_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_Temp_CFG3_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{ADC_Temp_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_Temp_CFG3_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_Temp_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_Temp_CFG3_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{ADC_Temp_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_Temp_CFG3_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (ADC_Temp_CFG3_FILTERTYPE_USED == ADC_Temp_FILTERTOPOLOGY_LOW_Q) */
        };

        const static CyUAB_config ADC_Temp_CFG3_UABH_A_FILTER_config = {
            ADC_Temp_UABH_A_waveConfig,
            (CyUAB_reg_pair*) ADC_Temp_CFG3_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(ADC_Temp_UABH_A_PARAM_REF_TIED,ADC_Temp_UABH_A_PARAM_AGND_TIED,
                ADC_Temp_UABH_A_PARAM_SW_CC,ADC_Temp_UABH_A_PARAM_SW_BB,ADC_Temp_UABH_A_PARAM_SW_AA),
            ADC_Temp_UABH_A_NUM_STEPS,
            (uint8)(ADC_Temp_UABH_A_ELEMENT_COUNT(ADC_Temp_CFG3_UABH_A_FILTER_initPairs))
        };

        const static CyUAB_config ADC_Temp_CFG3_UABH_B_FILTER_config = {
        ADC_Temp_UABH_B_waveConfig,
        (CyUAB_reg_pair*) ADC_Temp_CFG3_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(ADC_Temp_UABH_B_PARAM_REF_TIED,ADC_Temp_UABH_B_PARAM_AGND_TIED,
            ADC_Temp_UABH_B_PARAM_SW_CC,ADC_Temp_UABH_B_PARAM_SW_BB,ADC_Temp_UABH_B_PARAM_SW_AA),
        ADC_Temp_UABH_B_NUM_STEPS,
        (uint8)(ADC_Temp_UABH_B_ELEMENT_COUNT(ADC_Temp_CFG3_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != ADC_Temp_CFG3_FILTER_PRESENT) */


#endif /* (ADC_Temp_ANY_CONFIG_USES_FILTER  != 0u)  */

/*******************************************************************************
* Function Name: ADC_Temp_Start
****************************************************************************//**
*
* \brief Performs all required initialization for this component and enables the
*  power. The power will be set to the appropriate power based on the clock
*  frequency.
*
* \param None
*
* \return None
*
* \sideeffect None
*
* \globalvars
*  \ref ADC_Temp_initVar (RW)
*
*******************************************************************************/
void ADC_Temp_Start(void)
{
    if (ADC_Temp_INIT_VAR_INIT_FLAG != (ADC_Temp_INIT_VAR_INIT_FLAG & ADC_Temp_initVar))
    {
        ADC_Temp_Init();
        ADC_Temp_initVar |= ADC_Temp_INIT_VAR_INIT_FLAG;
    }

    ADC_Temp_Enable();

    return;
}

/*******************************************************************************
* Function Name: ADC_Temp_StartEx
****************************************************************************//**
*
* \brief This function starts the ADC_Temp and sets the Interrupt
* Service Routine to the provided address using the
* ADC_Temp_IRQ_StartEx() function. Refer to the Interrupt component
* datasheet for more information on the ADC_Temp_IRQ_StartEx() function.
*
* \param address This is the address of a user defined function for the ISR.
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/
void ADC_Temp_StartEx(cyisraddress address)
{
    ADC_Temp_Start();
    ADC_Temp_IRQ_StartEx(address);
    return;
}

/*******************************************************************************
* Function Name: ADC_Temp_Stop
****************************************************************************//**
*
* \brief This function stops ADC conversions and puts the ADC into its lowest
* power mode.
*
* \param None
*
* \return None
*
* \sideeffect
* Do not use the ADC_Temp_Stop() API to halt conversions. Instead use the
* ADC_Temp_StopConvert() API. If you use the ADC_Temp_Stop() API
* to halt conversions then later use the ADC_Temp_Start() and
* ADC_Temp_StartConvert() APIs to resume conversions, the first channel
* of the scan may be corrupt. The ADC_Temp_StopConvert() API will enable
* the ADC_Temp to complete the current scan of channels. After the
* channel scan is complete, the ADC_Temp will stop all conversions, which
* can be detected by the use of an ISR or the ADC_Temp_IsEndConversion()
* flag.
*
*******************************************************************************/
void ADC_Temp_Stop(void)
{
    #if(0u != ADC_Temp_ANY_CONFIG_USES_FILTER)
        if((ADC_Temp_allConfigs[ADC_Temp_currentConfig].miscConfig
           & ADC_Temp_MISC_CONFIG_FILTER_PRESENT_MSK)
           == ADC_Temp_MISC_CONFIG_FILTER_PRESENT_MSK)
        {
            ADC_Temp_UABH_A_Stop();
            ADC_Temp_UABH_B_Stop();
            ADC_Temp_FILTERAGND2SAR_BUFFER_Stop();
        }
    #endif /* ADC_Temp_ANY_CONFIG_USES_FILTER != 0u */
    ADC_Temp_SAR_CTRL_REG &= (uint32)~ADC_Temp_SAR_CTRL_ENABLED_MSK;
    return;
}

/* ****************************************************************************
* Function Name: ADC_Temp_InitConfig
****************************************************************************//*
*
* \brief Configures all of the registers for a given configuration for scanning.
*
* \param
* config: Pointer to the configuration structure
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/
void ADC_Temp_InitConfig(const ADC_Temp_CONFIG_STRUCT *config)
{
    uint32 chNum;
    uint32 tmpRegVal;

    /* If there is an internal SAR clock, set up its divider values. */
    #if (ADC_Temp_CLOCK_INTERNAL)
        ADC_Temp_intSarClock_Stop();
        ADC_Temp_intSarClock_SetFractionalDividerRegister(config->clkDivider, 0u);
        ADC_Temp_intSarClock_Start();
    #endif /* ADC_Temp_CLOCK_INTERNAL */

    /* If the current configuration has a filter, set up the UAB clock divider values. */
    #if(0u != ADC_Temp_ANY_CONFIG_USES_FILTER)
        if((config->miscConfig & ADC_Temp_MISC_CONFIG_FILTER_PRESENT_MSK)
            == ADC_Temp_MISC_CONFIG_FILTER_PRESENT_MSK)
        {
            ADC_Temp_intUabClock_Stop();
            ADC_Temp_intUabClock_SetFractionalDividerRegister(config->filterClkDivider, 0u);
            #if defined(ADC_Temp_cy_psoc4_sar_1__CLOCK_DIV_ID)
                /* If the SAR clock divider ID is known,
                 * start the internal UAB divider aligned to the SAR divider. */
                ADC_Temp_intUabClock_StartEx(ADC_Temp_cy_psoc4_sar_1__CLOCK_DIV_ID);
            #else
                /* Otherwise start it unaligned. */
                ADC_Temp_intUabClock_Start();
            #endif
        }
    #endif /* ADC_Temp_ANY_CONFIG_USES_FILTER != 0u */

    /* Init SAR and MUX registers */
    /* Enable the SAR internal pump when global pump is enabled */
    ADC_Temp_SAR_CTRL_REG = config->ctrl
        | (((ADC_Temp_PUMP_CTRL_REG & ADC_Temp_PUMP_CTRL_ENABLED) != 0u)
            ? ADC_Temp_SAR_CTRL_BOOSTPUMP_EN_MSK : 0u);

    ADC_Temp_SAR_SAMPLE_CTRL_REG = config->sampleCtrl;
    ADC_Temp_SAR_RANGE_THRES_REG = config->rangeThres;
    ADC_Temp_SAR_RANGE_COND_REG = config->rangeCond;
    ADC_Temp_SAR_SAMPLE_TIME01_REG = config->sampleTime01;
    ADC_Temp_SAR_SAMPLE_TIME23_REG = config->sampleTime23;

    /* Connect Vminus to VSSA when even one channel is single-ended or multiple channels configured */
    if(1u == ADC_Temp_MUX_SWITCH0_INIT)
    {
        ADC_Temp_MUX_SWITCH0_REG |= ADC_Temp_MUX_FW_VSSA_VMINUS;
        /* Set MUX_HW_CTRL_VSSA in MUX_SWITCH_HW_CTRL when multiple channels enabled */
        if(1ul < config->numChannels)
        {
            ADC_Temp_MUX_SWITCH_HW_CTRL_REG |= ADC_Temp_MUX_FW_VSSA_VMINUS;
        }
    }

    /* Clear and set interrupt masks */
    ADC_Temp_SAR_SATURATE_INTR_MASK_REG = 0u;
    ADC_Temp_SAR_RANGE_INTR_MASK_REG = 0u;
    ADC_Temp_SAR_SATURATE_INTR_MASK_REG = config->satIntMask;
    ADC_Temp_SAR_RANGE_INTR_MASK_REG = config->rangeIntMask;
    ADC_Temp_SAR_INTR_MASK_REG = ADC_Temp_EOS_MASK;

    for(chNum = 0u; chNum < config->numChannels; chNum++)
    {
        tmpRegVal = (ADC_Temp_channelsConfig[config->channelBase + chNum]
        & ADC_Temp_CHANNEL_CONFIG_MASK);

        #if(ADC_Temp_TOTAL_CHANNELS_NUM > 1)
            tmpRegVal |= ADC_Temp_InputsPlacement[config->channelBase + chNum];
            /*Non-paired differential channels set NEG_ADDR_EN and clear DIFFERENTIAL_EN */
            if(0u != (ADC_Temp_InputsPlacement[config->channelBase + chNum] & ADC_Temp_CHANNEL_CONFIG_NEG_ADDR_EN_MSK))
            {
                tmpRegVal &= ~ADC_Temp_SAR_CHAN_CONFIG_DIFFERENTIAL_EN_MSK;
            }
        #endif

        CY_SET_REG32((reg32 *)(ADC_Temp_SAR_CHAN_CONFIG_IND + (uint32)(chNum << 2)), tmpRegVal);
    }

    return;
}

/* ****************************************************************************
* Function Name: ADC_Temp_SetDFTControl
****************************************************************************//*
*
* \brief Internal function to configure the DFT_CTRL register.
* This register is a non-retention register therefore it resets
* when the SAR block is powered down.
* The register must be configured every time the SAR block is enabled.
*
* \param
* config: Pointer to the configuration structure
*
*******************************************************************************/
static void ADC_Temp_SetDFTControl(const ADC_Temp_CONFIG_STRUCT *config)
{
    /* Double the non-overlap delay and latch enable time when using */
    /* internal reference without bypass cap */
    uint32 tmpRegVal = ADC_Temp_SAR_DFT_CTRL_REG;
    if(((config->ctrl & ADC_Temp__SAR_CTRL_VREF_BYP_AND_SEL_MSK)
        == ADC_Temp__INTERNAL1024)
        || ((config->ctrl & ADC_Temp__SAR_CTRL_VREF_BYP_AND_SEL_MSK)
        == ADC_Temp__INTERNALVREF))
    {
        tmpRegVal &= ~ADC_Temp_SAR_DFT_CTRL_DCEN_MSK;
        tmpRegVal |= ADC_Temp_SAR_DFT_CTRL_DLY_INC_MSK;
    }
    else
    {
        tmpRegVal |= ADC_Temp_SAR_DFT_CTRL_DCEN_MSK;
        tmpRegVal &= (uint32)~ADC_Temp_SAR_DFT_CTRL_DLY_INC_MSK;
    }
    ADC_Temp_SAR_DFT_CTRL_REG = tmpRegVal;
}

/* ****************************************************************************
* Function Name: ADC_Temp_SelectConfig
****************************************************************************//*
*
* \brief Selects the predefined configuration for scanning. Disables
* and re-enables the SAR and filter (if filter used).
*
* \param config Number of configuration  in the ADC_Temp.
*
* \param restart Set to 1u to restart the ADC_Temp after
* selecting the configuration.
*
*******************************************************************************/
void ADC_Temp_SelectConfig(uint32 config, uint32 restart)
{
    /* Check whether the configuration number is valid or not */
    if(ADC_Temp_TOTAL_CONFIGS > config)
    {
        /* Stop the ADC before changing configurations */
        ADC_Temp_Stop();
        ADC_Temp_selected = 1u;

        if(0u == ADC_Temp_initVar)
        {
            ADC_Temp_Init();
            ADC_Temp_initVar |= ADC_Temp_INIT_VAR_INIT_FLAG;
        }
        #if (ADC_Temp_VREF_ROUTED)
            ADC_Temp_vrefAMux_DisconnectAll();
        #endif
        ADC_Temp_InitConfig(&ADC_Temp_allConfigs[config]);
        #if (ADC_Temp_VREF_ROUTED)
            ADC_Temp_vrefAMux_Select((uint8)config);
        #endif
        #if(0u != ADC_Temp_ANY_CONFIG_USES_FILTER)
            ADC_Temp_filterVinMux_Select((uint8)config);
            ADC_Temp_filterInit(config);
        #endif
        ADC_Temp_SAR_CHAN_EN_REG = ADC_Temp_allConfigs[config].chanEn;
        ADC_Temp_SAR_RANGE_INTR_MASK_REG = ADC_Temp_allConfigs[config].rangeIntMask;
        ADC_Temp_SAR_SATURATE_INTR_MASK_REG = ADC_Temp_allConfigs[config].satIntMask;
        ADC_Temp_currentConfig = config;

        if(1u == restart)
        {
            /* Restart the ADC */
            ADC_Temp_Start();

            /* Restart the scan */
            ADC_Temp_StartConvert();
        }
    }
    return;
}

/*******************************************************************************
* Function Name: ADC_Temp_StartConvert
****************************************************************************//**
*
* \brief In continuous mode, this API starts the conversion process and it runs
* continuously.

* In Single Shot mode, the function triggers a single scan and
* every scan requires a call of this function. The mode is set with the
* Sample Mode parameter in the customizer. The customizer setting can be
* overridden at run time with the ADC_Temp_SetConvertMode() function.
*
* \param None
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/
void ADC_Temp_StartConvert(void)
{
    /* Freerunning mode */
    if((ADC_Temp_SAR_SAMPLE_CTRL_REG
        & ADC_Temp_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK)
        == ADC_Temp_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK)
    {
        ADC_Temp_SAR_SAMPLE_CTRL_REG |= ADC_Temp_SAR_SAMPLE_CTRL_CONTINUOUS_MSK ;
    }
    else /* Firmware trigger */
    {
        ADC_Temp_SAR_START_CTRL_REG = ADC_Temp_SAR_START_CTRL_FW_TRIGGER_MSK;
    }

    return;
}

/*******************************************************************************
* Function Name: ADC_Temp_StopConvert
****************************************************************************//**
*
* \brief Forces the ADC_Temp to stop conversions. If a conversion is
* currently executing, that conversion will complete, but no further conversions
* will occur.
*
* \param None
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/
void ADC_Temp_StopConvert(void)
{
    if((ADC_Temp_SAR_SAMPLE_CTRL_REG
        & ADC_Temp_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK)
        == ADC_Temp_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK)
    {
        ADC_Temp_SAR_SAMPLE_CTRL_REG &= ~ADC_Temp_SAR_SAMPLE_CTRL_CONTINUOUS_MSK;

        if((ADC_Temp_allConfigs[ADC_Temp_currentConfig].miscConfig
            & ADC_Temp_MISC_CONFIG_FILTER_PRESENT_MSK)
            == ADC_Temp_MISC_CONFIG_FILTER_PRESENT_MSK)
        {
            /* Re-synchronize the Filter if a filter is present */
            ADC_Temp_Stop();
            ADC_Temp_Start();
        }
    }

    return;
}
/*******************************************************************************
* Function Name: ADC_Temp_SetConvertMode
****************************************************************************//**
*
* \brief Sets the conversion mode to either Single-Shot or continuous. This
* function overrides the settings applied in the customizer. Changing
* configurations will restore the values set in the customizer.
*
* \param mode Sets the conversion mode. See table below for details.
* | Options                          | Description                             |
* | :------------------------------- | :-------------------------------------- |
* | ADC_Temp_SINGLE_SHOT     | Calling the ADC_Temp_StartConvert() function after setting mode this will trigger a single scan. Sets the SOC signal to be edge sensitive, each edge will trigger a single scan. |
* | ADC_Temp_CONTINUOUS      | Calling the ADC_Temp_StartConvert() function after setting this mode trigger continuous scanning. This mode sets the SOC signal to be level sensitive. The ADC_Temp will continuously scan while soc is active. |
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/
void ADC_Temp_SetConvertMode(uint32 mode)
{
    if(ADC_Temp_CONTINUOUS == mode)
    {
        ADC_Temp_SAR_SAMPLE_CTRL_REG |= ADC_Temp_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK;
    }
    else
    {
        ADC_Temp_SAR_SAMPLE_CTRL_REG &= ~ADC_Temp_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK;
    }
}
/* ****************************************************************************
* Function Name: ADC_Temp_IRQ_Enable
****************************************************************************//*
*
* \brief Enables interrupts to occur at the end of a conversion. Global
* interrupts must also be enabled for the ADC_Temp interrupts to occur.
*
* \param None
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/


/* ****************************************************************************
* Function Name: ADC_Temp_IRQ_Disable
****************************************************************************//*
*
* \brief Disables end of conversion interrupts.
*
* \param None
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/


/*******************************************************************************
* Function Name: ADC_Temp_SetEosMask
****************************************************************************//**
*
* \brief Sets of clears the End of Scan (EOS) interrupt mask.
*
* \param mask 1 to set the mask, 0 to clear the mask.
*
* \return None
*
* \sideeffect All other bits in the INTR register are cleared by this function.
*
*******************************************************************************/
void ADC_Temp_SetEosMask(uint32 mask)
{
    ADC_Temp_SAR_INTR_MASK_REG = mask & ADC_Temp_EOS_MASK;

    return;
}

/* ****************************************************************************
* Function Name: ADC_Temp_SetChanMask
****************************************************************************//*
*
* \brief Sets enable/disable mask for all channels in current configuration.
*
*
* \param enableMask
*  Channel enable/disable mask.
*
* \sideeffect
*  None.
*
*******************************************************************************/
void ADC_Temp_SetChanMask(uint32 enableMask)
{
    uint32 chanCount = ADC_Temp_allConfigs[ADC_Temp_currentConfig].numChannels;
    enableMask &= (uint32)((uint32)(1ul << chanCount) - 1ul);
    ADC_Temp_SAR_CHAN_EN_REG = enableMask;
    return;
}

/*******************************************************************************
* Function Name: ADC_Temp_IsEndConversion
****************************************************************************//**
*
* \brief Immediately returns the status of the conversion or does not return
* (blocking) until the conversion completes, depending on the retMode parameter.
*
* \param retMode Check conversion return mode. See the following table for
* options.
* | Options                              | Description                             |
* | :-------------------------------     | :-------------------------------------- |
* | ADC_Temp_RETURN_STATUS       | Immediately returns the conversion status for sequential channels. If the value returned is zero, the conversion is not complete, and this function should be retried until a nonzero result is returned. |
* | ADC_Temp_WAIT_FOR_RESULT     | Does not return a result until the ADC_Temp conversion of all sequential channels is complete. |
*
* \return uint8: If a nonzero value is returned, the last conversion is complete.
* If the returned value is zero, the ADC_Temp is still calculating the last result.
*
* \sideeffect This function reads the end of conversion status, and clears it afterward.
*
*******************************************************************************/
uint32 ADC_Temp_IsEndConversion(uint32 retMode)
{
    uint32 endOfConversion = 0u;
    uint32 wdt = 0x3FFFFFFuL; /* Watchdog timer for blocking while loop */
    if((ADC_Temp_RETURN_STATUS == retMode) || (ADC_Temp_WAIT_FOR_RESULT == retMode))
    {
        do
        {
            endOfConversion = ADC_Temp_SAR_INTR_REG & ADC_Temp_EOS_MASK;
            wdt--;
        }while(((0u == endOfConversion)
            && (((uint32) retMode & ADC_Temp_WAIT_FOR_RESULT) != 0u))
            && (0uL != wdt));

        if(0u != endOfConversion)
        {
            /* Clear EOS bit */
            ADC_Temp_SAR_INTR_REG = ADC_Temp_EOS_MASK;
        }
    }

    return endOfConversion;
}

/* ****************************************************************************
* Function Name: ADC_Temp_IsChannelSigned(uint32 chan)
****************************************************************************//*
*
* Determines if the provided channel is in signed format.
*
* \param chan The ADC_Temp channel to check.
*
* \return None
*
* \sideeffect None
*
*
*******************************************************************************/
static int32 ADC_Temp_IsChannelSigned(uint32 chan)
{
    int32 isSigned = 0;
    uint32 chanConfig;

    chanConfig = CY_GET_REG32((reg32 *)(ADC_Temp_SAR_CHAN_CONFIG_IND + (uint32)(chan << 2u)));
    /* If differential mode */
    if(0u != (chanConfig & ADC_Temp_CHANNEL_CONFIG_DIFF_ALL_MSK))
    {
        /*If signed differential */
        if((ADC_Temp_allConfigs[ADC_Temp_currentConfig].sampleCtrl
            & ADC_Temp_SAR_SAMPLE_CTRL_DIFFERENTIAL_SIGNED_MSK) != 0u)
        {
            isSigned = 1;
        }
    }
    else
    {
        if((ADC_Temp_allConfigs[ADC_Temp_currentConfig].sampleCtrl
            & ADC_Temp_SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED_MSK) != 0u)
        {
            isSigned = 1;
        }
    }
    return isSigned;
}
/*******************************************************************************
* Function Name: ADC_Temp_GetResult16
****************************************************************************//**
*
* \brief Gets the data available in the channel result data register
*
* \param chan The ADC_Temp channel to read the result from. The first
* channel is 0 and the injection channel if enabled is the number of valid
* channels.
*
* \return Returns converted data as a signed 16-bit integer.
*
* \sideeffect None
*
*******************************************************************************/
int16 ADC_Temp_GetResult16(uint32 chan)
{
    uint32 adcResult;

    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < ADC_Temp_allConfigs[ADC_Temp_currentConfig].numChannels);

    if(ADC_Temp_allConfigs[ADC_Temp_currentConfig].numChannels > chan)
    {
        adcResult = CY_GET_REG32((reg32 *)(ADC_Temp_SAR_CHAN_RESULT_IND + (uint32)(chan << 2u))) &
            ADC_Temp_RESULT_MASK;
    }
    else
    {
        adcResult = 0u;
    }

    return (int16) adcResult;
}

/*******************************************************************************
* Function Name: ADC_Temp_GetResult32
****************************************************************************//**
*
* \brief Gets the data available in the channel result data register.
*
* \param chan The ADC_Temp channel to read the result from. The first
* channel is 0 and the injection channel if enabled is the number of valid
* channels.
*
* \return Returns converted data as a signed 32-bit integer.
*
* \sideeffect None
*
*******************************************************************************/
int32 ADC_Temp_GetResult32(uint32 chan)
{
    uint32 adcResult;
    int16 adcResult16;
    int32 finalResult;

    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < ADC_Temp_allConfigs[ADC_Temp_currentConfig].numChannels);

    if(ADC_Temp_allConfigs[ADC_Temp_currentConfig].numChannels > chan)
    {
        adcResult = CY_GET_REG32((reg32 *)(ADC_Temp_SAR_CHAN_RESULT_IND + (uint32)(chan << 2u))) &
            ADC_Temp_RESULT_MASK;
    }
    else
    {
        adcResult = 0u;
    }
    /* Sign extend if channel is signed format */
    if(ADC_Temp_IsChannelSigned(chan) == 1)
    {
        adcResult16 = (int16) adcResult;
        finalResult = (int32) adcResult16;
    }
    else
    {
        finalResult = (int32) adcResult;
    }
    return finalResult;
}

/*******************************************************************************
* Function Name: ADC_Temp_SetLowLimit
****************************************************************************//**
*
* \brief Sets the low limit parameter for a limit condition.
*
* \param lowLimit The low limit for a limit condition.
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/
void ADC_Temp_SetLowLimit(uint32 lowLimit)
{
    ADC_Temp_SAR_RANGE_THRES_REG &= ~(uint32)(ADC_Temp_SAR_RANGE_THRES_RANGE_LOW_MSK);
    ADC_Temp_SAR_RANGE_THRES_REG |= lowLimit & ADC_Temp_SAR_RANGE_THRES_RANGE_LOW_MSK;
    return;
}

/*******************************************************************************
* Function Name: ADC_Temp_SetHighLimit
****************************************************************************//**
*
* \brief Sets the high limit parameter for a limit condition.
*
* \param highLimit The high limit for a limit condition.
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/
void ADC_Temp_SetHighLimit(uint32 highLimit)
{
    ADC_Temp_SAR_RANGE_THRES_REG &= ~(uint32)(ADC_Temp_SAR_RANGE_THRES_RANGE_HIGH_MSK);
    ADC_Temp_SAR_RANGE_THRES_REG |= (uint32)(highLimit << ADC_Temp_SAR_RANGE_THRES_RANGE_HIGH_SHFT);
    return;
}

/*******************************************************************************
* Function Name: ADC_Temp_SetLimitMask
****************************************************************************//**
*
* \brief Sets the channel limit condition mask.
*
* \param limitMask Sets which channels that may cause a limit condition interrupt.
* Setting bits for channels that do not exist will have no effect. For example,
* if only 6  channels were enabled, setting a mask of 0x0103 would only enable
* the last two channels (0 and 1).
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/
void ADC_Temp_SetLimitMask(uint32 limitMask)
{
    uint32 chanCount = ADC_Temp_allConfigs[ADC_Temp_currentConfig].numChannels;
    limitMask &= (uint32)((uint32)(1ul << chanCount) - 1ul);
    ADC_Temp_SAR_RANGE_INTR_MASK_REG = limitMask;
    return;
}

/*******************************************************************************
* Function Name: ADC_Temp_SetSatMask
****************************************************************************//**
*
* \brief Sets the channel saturation event mask.
*
* \param satMask Sets which channels that may cause a saturation event interrupt.
* Setting bits for channels that do not exist will have no effect. For example,
* if only 8 channels were enabled, setting a mask of 0x01C0 would only enable two
* channels (6 and 7).
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/
void ADC_Temp_SetSatMask(uint32 satMask)
{
    uint32 chanCount = ADC_Temp_allConfigs[ADC_Temp_currentConfig].numChannels;
    satMask &= (uint32)((uint32)(1ul << chanCount) - 1ul);
    ADC_Temp_SAR_SATURATE_INTR_MASK_REG = satMask;
    return;
}

/*******************************************************************************
* Function Name: ADC_Temp_SetOffset
****************************************************************************//**
*
* \brief Sets the ADC offset that is used by the functions ADC_Temp_CountsTo_uVolts,
* ADC_Temp_CountsTo_mVolts, and ADC_Temp_CountsTo_Volts.
*
* Offset is applied to counts before unit scaling and gain.  All CountsTo_[mV, uV, V]olts()
* functions use the following equation:
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* See CountsTo_Volts() for more about this formula.
*
* To set channel 0's offset based on known V_offset_mV, use:
*     ADC_Temp_SetOffset(0uL, -1 * V_offset_mV * (1uL << (Resolution - 1)) / V_ref_mV);
*
* \param chan ADC_Temp channel number.
*
* \param offset This value is a measured value when the inputs are shorted or
* connected to the same input voltage.
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/
void ADC_Temp_SetOffset(uint32 chan, int16 offset)
{
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < ADC_Temp_allConfigs[ADC_Temp_currentConfig].numChannels);

    ADC_Temp_offset[ADC_Temp_allConfigs[ADC_Temp_currentConfig].channelBase + chan] = offset;
    return;
}

/*******************************************************************************
* Function Name: ADC_Temp_SetGain
****************************************************************************//**
*
* \brief Sets the ADC_Temp gain in counts per 10 volt for the voltage
* conversion functions. This value is set by default by the reference and
* input range settings. Gain is applied after offset and unit scaling.  All
* CountsTo_[mV, uV, V]olts() functions use the following equation:
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* See CountsTo_Volts() for more about this formula.
*
* To set channel 0's gain based on known V_ref_mV, use:
*     ADC_Temp_SetGain(0uL, 10000 * (1uL << (Resolution - 1)) / V_ref_mV);
*
* \param chan ADC_Temp channel number.
*
* \param adcGain ADC_Temp gain in counts per 10 volt.
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/
void ADC_Temp_SetGain(uint32 chan, int32 adcGain)
{
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < ADC_Temp_allConfigs[ADC_Temp_currentConfig].numChannels);

    ADC_Temp_countsPer10Volt[ADC_Temp_allConfigs[ADC_Temp_currentConfig].channelBase + chan]
    = adcGain;
    return;
}
/*******************************************************************************
* Function Name: ADC_Temp_RawCounts2Counts
****************************************************************************//**
*
* \brief Converts the output of the SAR to an idealized count value.
*
* Divides by averaging amount, if needed, and subtracts offset.
*
* \param chan ADC_Temp channel number.
*
* \param adcCounts Result from the ADC_Temp conversion.
*
* \return Averaged and offset counts.
*
* \sideeffect None
*******************************************************************************/
int16 ADC_Temp_RawCounts2Counts(uint32 chan, int16 adcCounts)
{
    uint32 temp;
    uint32 averageAdcSamplesDiv;
    uint32 rawChannel;
    rawChannel = ADC_Temp_allConfigs[ADC_Temp_currentConfig].channelBase + chan;

    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < ADC_Temp_allConfigs[ADC_Temp_currentConfig].numChannels);

    /* Divide the adcCount when accumulate averaging mode selected */
    /* If Average mode != fixed */
    if((ADC_Temp_allConfigs[ADC_Temp_currentConfig].sampleCtrl
        & ADC_Temp_SAR_SAMPLE_CTRL_AVG_SHIFT_MSK)
        != ADC_Temp_SAR_SAMPLE_CTRL_AVG_SHIFT_MSK)
    {
        /* If Channel uses averaging */
        if((ADC_Temp_channelsConfig[rawChannel] & ADC_Temp_SAR_CHAN_CONFIG_AVG_EN_MSK) != 0u)
        {
            /* Divide by 2^(AVG_CNT + 1) */
            averageAdcSamplesDiv = ((ADC_Temp_allConfigs[ADC_Temp_currentConfig].sampleCtrl
                & ADC_Temp_SAR_SAMPLE_CTRL_AVG_CNT_MSK)
                >> ADC_Temp_SAR_SAMPLE_CTRL_AVG_CNT_SHFT);
            averageAdcSamplesDiv = (1uL << (averageAdcSamplesDiv + 1uL));
                        /* When it's "Sequential, Sum", divider limit is 16 */
            /* If Mode is ACCUNDUMP */
            if((ADC_Temp_allConfigs[ADC_Temp_currentConfig].sampleCtrl
                & ADC_Temp_SAR_SAMPLE_CTRL_AVG_MODE_MSK)
                != ADC_Temp_SAR_SAMPLE_CTRL_AVG_MODE_MSK)
            {
                if (averageAdcSamplesDiv > 16uL)
                {
                    averageAdcSamplesDiv = 16uL;
                }
            }
            /* If unsigned format, prevent sign extension */
            if(0 == ADC_Temp_IsChannelSigned(chan))
            {
                temp = ((uint16) adcCounts / averageAdcSamplesDiv);
                adcCounts = (int16) temp;
            }
            else
            {
                adcCounts /= (int16) averageAdcSamplesDiv;
            }
        }
    }
    /* Subtract ADC offset */
    adcCounts -= ADC_Temp_offset[rawChannel];
    return adcCounts;
}

/*******************************************************************************
* Function Name: ADC_Temp_CountsTo_Volts
****************************************************************************//**
*
* \brief Converts the ADC output to Volts as a float32. For example, if the ADC
* measured 0.534 volts, the return value would be 0.534.
* The calculation of voltage depends on the contents of ADC_Temp_offset[],
* ADC_Temp_countsPer10Volt[], and other parameters.  The equation used is:
*
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* -Counts = Raw Counts from SAR register
* -AvgDivider = divider based on averaging mode
*     -Sequential, Sum: AvgDivider = number averaged
*         Note: The divider should be a maximum of 16. If using more averages,
*         pre-scale Counts by (number averaged / 16)
*     -Interleaved, Sum: AvgDivider = number averaged
*     -Sequential, Fixed: AvgDivider = 1
* -Offset = ADC_Temp_offset[]
* -TEN_VOLT = 10V constant and unit scalar.
* -Gain = ADC_Temp_countsPer10Volt[]
*
* When the Vref is based on Vdda, the value used for Vdda is set for the project
* in the System tab of the DWR.
*
* \param chan ADC_Temp channel number.
*
* \param adcCounts Result from the ADC_Temp conversion.
*
* \return Result in Volts.
*
* \sideeffect None
*
*******************************************************************************/
float32 ADC_Temp_CountsTo_Volts(uint32 chan, int16 adcCounts)
{
    float32 result_Volts = 0.0f;
    uint32 rawChannel;
    rawChannel = ADC_Temp_allConfigs[ADC_Temp_currentConfig].channelBase + chan;

    if((ADC_Temp_allConfigs[ADC_Temp_currentConfig].sampleCtrl
        & ADC_Temp_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
        != ADC_Temp_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
    {
        adcCounts = ADC_Temp_RawCounts2Counts(chan, adcCounts);

        result_Volts = ((float32)adcCounts * ADC_Temp_10V_COUNTS)
            / (float32)ADC_Temp_countsPer10Volt[rawChannel];
    }
    return result_Volts;
}

/*******************************************************************************
* Function Name: ADC_Temp_CountsTo_mVolts
****************************************************************************//**
*
* \brief Converts the ADC output to millivolts as an int16. For example, if the ADC
* measured 0.534 volts, the return value would be 534.
* The calculation of voltage depends on the contents of ADC_Temp_offset[],
* ADC_Temp_countsPer10Volt[], and other parameters.  The equation used is:
*
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* -Counts = Raw Counts from SAR register
* -AvgDivider = divider based on averaging mode
*     -Sequential, Sum: AvgDivider = number averaged
*         Note: The divider should be a maximum of 16. If using more averages,
*         pre-scale Counts by (number averaged / 16)
*     -Interleaved, Sum: AvgDivider = number averaged
*     -Sequential, Fixed: AvgDivider = 1
* -Offset = ADC_Temp_offset[]
* -TEN_VOLT = 10V constant and unit scalar.
* -Gain = ADC_Temp_countsPer10Volt[]
*
* When the Vref is based on Vdda, the value used for Vdda is set for the project
* in the System tab of the DWR.
*
* \param chan ADC_Temp channel number.
*
* \param adcCounts Result from the ADC_Temp conversion.
*
* \return Result in mV.
*
* \sideeffect None.
*
*******************************************************************************/
int16 ADC_Temp_CountsTo_mVolts(uint32 chan, int16 adcCounts)
{
    int16 result_mVolts = 0;
    uint32 rawChannel;

    rawChannel = ADC_Temp_allConfigs[ADC_Temp_currentConfig].channelBase + chan;

    if((ADC_Temp_allConfigs[ADC_Temp_currentConfig].sampleCtrl
        & ADC_Temp_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
        != ADC_Temp_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
    {
        adcCounts = ADC_Temp_RawCounts2Counts(chan, adcCounts);

        result_mVolts = (int16)((((int32)adcCounts * ADC_Temp_10MV_COUNTS) + ( (adcCounts > 0) ?
                 (ADC_Temp_countsPer10Volt[rawChannel] / 2)
                : (-(ADC_Temp_countsPer10Volt[rawChannel] / 2)) ))
                 / ADC_Temp_countsPer10Volt[rawChannel]);
    }
    return result_mVolts;
}

/*******************************************************************************
* Function Name: ADC_Temp_CountsTo_uVolts
****************************************************************************//**
*
* \brief Converts the ADC output to microvolts as an int32. For example, if the ADC
* measured 0.534 volts, the return value would be 534000.
* The calculation of voltage depends on the contents of ADC_Temp_offset[],
* ADC_Temp_countsPer10Volt[], and other parameters.  The equation used is:
*
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* -Counts = Raw Counts from SAR register
* -AvgDivider = divider based on averaging mode
*     -Sequential, Sum: AvgDivider = number averaged
*         Note: The divider should be a maximum of 16. If using more averages,
*         pre-scale Counts by (number averaged / 16)
*     -Interleaved, Sum: AvgDivider = number averaged
*     -Sequential, Fixed: AvgDivider = 1
* -Offset = ADC_Temp_offset[]
* -TEN_VOLT = 10V constant and unit scalar.
* -Gain = ADC_Temp_countsPer10Volt[]
*
* When the Vref is based on Vdda, the value used for Vdda is set for the project
* in the System tab of the DWR.
*
* \param chan ADC_Temp channel number.
*
* \param adcCounts Result from the ADC_Temp conversion.
*
* \return Result in microvolts.
*
* \sideeffect None
*
*******************************************************************************/
int32 ADC_Temp_CountsTo_uVolts(uint32 chan, int16 adcCounts)
{
    int64 result_uVolts = 0;
    uint32 rawChannel;
    rawChannel = ADC_Temp_allConfigs[ADC_Temp_currentConfig].channelBase + chan;

    if((ADC_Temp_allConfigs[ADC_Temp_currentConfig].sampleCtrl
        & ADC_Temp_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
        != ADC_Temp_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
    {
        adcCounts = ADC_Temp_RawCounts2Counts(chan, adcCounts);

        result_uVolts = ((int64)adcCounts * ADC_Temp_10UV_COUNTS)
            / ADC_Temp_countsPer10Volt[rawChannel];
    }
    return ( (int32)result_uVolts );
}

#if(0u != ADC_Temp_ANY_CONFIG_USES_FILTER)

    /*******************************************************************************
    * Function Name: ADC_Temp_TrimFilterVos
    ****************************************************************************//**
    *
    * \brief Run an algorithm to reduce voltage offset using the UAB's opamp and
    * agnd buffer trim.
    *
    * During trimming, the filter inputs are disconnected from the UAB block,
    * the non-inverting input of both UAB opamps are connected to Agnd,
    * and SAR is used as a comparator.
    *
    * Trimming is done by comparing the filter output with Agnd.
    * The algorithm steps through the Opamp trim codes first and then the
    * Agnd trim codes to find where the filter output crosses Agnd.
    * For each trim code, a blocking delay is used to allow the filter output
    * to settle before reading the comparator status. This delay is equivalent
    * to 9 * tau, where tau is the filter time constant:
    *
    * tau = 1 / (2 * pi * (Fcorner or Bandwidth))
    *
    * The time constant is calculated using the bandwidth for Band pass and
    * Band stop and the corner frequency for Low pass and High pass.
    * The algorithm can check up to 40 different trim codes, but it will typically
    * complete in much less time.
    *
    * Once trimming is complete, the UAB is restored to its original configuration.
    *
    * \Note
    * The ADC conversions must be started and Agnd must be supplied to the
    * component before calling this function.
    *
    *******************************************************************************/
    void ADC_Temp_TrimFilterVos(void)
    {
        uint32 opampTrim = 0uL;
        uint32 agndTrim = 0uL;
        uint32 compStatus = 0uL;

        ADC_Temp_SetupComparatorTrim();

        /* Sweep from center to crossing */
        compStatus = ADC_Temp_SetOpampAndAgndTrim(ADC_Temp_OPAMP_TRIM_POS_BASE, ADC_Temp_AGND_TRIM_POS_BASE);
        if (0uL == compStatus)
        {
            opampTrim = ADC_Temp_RaiseOpampTrimToCrossing(ADC_Temp_OPAMP_TRIM_POS_BASE);
            agndTrim = ADC_Temp_RaiseAgndTrimToCrossing(ADC_Temp_AGND_TRIM_POS_BASE);
            if ((agndTrim == (ADC_Temp_AGND_TRIM_POS_LIMIT - 1uL))
                && (opampTrim != (ADC_Temp_OPAMP_TRIM_POS_LIMIT - 1uL)))
            {
                opampTrim = ADC_Temp_IncOpampTrim(opampTrim);
                (void) ADC_Temp_SetOpampAndAgndTrim(opampTrim, ADC_Temp_AGND_TRIM_POS_BASE);
                (void) ADC_Temp_LowerAgndTrimToCrossing(ADC_Temp_AGND_TRIM_POS_BASE);
            }
        }
        else
        {
            opampTrim = ADC_Temp_LowerOpampTrimToCrossing(ADC_Temp_OPAMP_TRIM_POS_BASE);
            agndTrim = ADC_Temp_LowerAgndTrimToCrossing(ADC_Temp_AGND_TRIM_POS_BASE);
            if ((agndTrim == (ADC_Temp_AGND_TRIM_NEG_LIMIT - 1uL))
                && (opampTrim != (ADC_Temp_OPAMP_TRIM_NEG_LIMIT - 1uL)))
            {
                opampTrim = ADC_Temp_DecOpampTrim(opampTrim);
                (void) ADC_Temp_SetOpampAndAgndTrim(opampTrim, ADC_Temp_AGND_TRIM_POS_BASE);
                (void) ADC_Temp_RaiseAgndTrimToCrossing(ADC_Temp_AGND_TRIM_POS_BASE);
            }
        }

        ADC_Temp_UndoComparatorTrimSetup();
    }

    /*******************************************************************************
    * Function Name: ADC_Temp_SetupComparatorTrim
    ********************************************************************************
    *
    * Make proper connections to being trimming the Agnd buffer
    * and Opamp offset.
    *
    *******************************************************************************/
    static void ADC_Temp_SetupComparatorTrim(void)
    {
        ADC_Temp_filterVinMux_Select(ADC_Temp_FILTER_AMUX_CHANNEL);
    }

    /*******************************************************************************
    * Function Name: ADC_Temp_UndoComparatorTrimSetup
    ********************************************************************************
    *
    * Undo all changes made in ADC_Temp_SetupComparatorTrim()
    * to bring the Component back to normal operation.
    *
    *******************************************************************************/
    static void ADC_Temp_UndoComparatorTrimSetup(void)
    {
        ADC_Temp_filterVinMux_Select((uint8)ADC_Temp_currentConfig);
    }

    /*******************************************************************************
    * Function Name: ADC_Temp_RaiseOpampTrimToCrossing
    ********************************************************************************
    *
    * Step through the Opamp trim codes in increasing order
    * to find the point where the offset crosses Agnd.
    *
    *******************************************************************************/
    static uint32 ADC_Temp_RaiseOpampTrimToCrossing(uint32 startTrim)
    {
        uint32 opampTrim;
        uint32 lastOpampTrim;
        uint32 compStatus;

        lastOpampTrim = startTrim;
        for (opampTrim = startTrim;
            opampTrim != ADC_Temp_OPAMP_TRIM_NEG_LIMIT;
            opampTrim = ADC_Temp_IncOpampTrim(opampTrim))
        {
            compStatus = ADC_Temp_SetOpampAndAgndTrim(opampTrim, ADC_Temp_AGND_TRIM_POS_BASE);
            if (0uL != compStatus)
            {
                (void) ADC_Temp_SetOpampTrim(lastOpampTrim);
                break;
            }
            lastOpampTrim = opampTrim;
        }

        return lastOpampTrim;
    }

    /*******************************************************************************
    * Function Name: ADC_Temp_LowerOpampTrimToCrossing
    ********************************************************************************
    *
    * Step through the Opamp trim codes in decreasing order
    * to find the point where the offset crosses Agnd.
    *
    *******************************************************************************/
    static uint32 ADC_Temp_LowerOpampTrimToCrossing(uint32 startTrim)
    {
        uint32 opampTrim;
        uint32 lastOpampTrim;
        uint32 compStatus;

        lastOpampTrim = startTrim;
        for (opampTrim = startTrim;
            opampTrim != ADC_Temp_OPAMP_TRIM_NEG_LIMIT;
            opampTrim = ADC_Temp_DecOpampTrim(opampTrim))
        {
            compStatus = ADC_Temp_SetOpampAndAgndTrim(opampTrim, ADC_Temp_AGND_TRIM_POS_BASE);
            if (0uL == compStatus)
            {
                (void) ADC_Temp_SetOpampTrim(lastOpampTrim);
                break;
            }
            lastOpampTrim = opampTrim;
        }

        return lastOpampTrim;
    }

    /*******************************************************************************
    * Function Name: ADC_Temp_RaiseAgndTrimToCrossing
    ********************************************************************************
    *
    * Step through the Agnd trim codes in increasing order
    * to find the point where the offset crosses Agnd.
    *
    *******************************************************************************/
    static uint32 ADC_Temp_RaiseAgndTrimToCrossing(uint32 startTrim)
    {
        uint32 agndTrim;
        uint32 lastAgndTrim;
        uint32 compStatus;

        lastAgndTrim = startTrim;
        for (agndTrim = startTrim;
            agndTrim != ADC_Temp_AGND_TRIM_NEG_LIMIT;
            agndTrim = ADC_Temp_IncAgndTrim(agndTrim))
        {
            compStatus = ADC_Temp_SetAgndTrim(agndTrim);
            if (0uL != compStatus)
            {
                (void) ADC_Temp_SetAgndTrim(lastAgndTrim);
                break;
            }
            lastAgndTrim = agndTrim;
        }

        return lastAgndTrim;
    }

    /*******************************************************************************
    * Function Name: ADC_Temp_LowerAgndTrimToCrossing
    ********************************************************************************
    *
    * Step through the Agnd trim codes in decreasing order
    * to find the point where the offset crosses Agnd.
    *
    *******************************************************************************/
    static uint32 ADC_Temp_LowerAgndTrimToCrossing(uint32 startTrim)
    {
        uint32 agndTrim = startTrim;
        uint32 lastAgndTrim = agndTrim;
        uint32 compStatus = 1uL;

        lastAgndTrim = startTrim;
        for (agndTrim = startTrim;
            agndTrim != ADC_Temp_AGND_TRIM_NEG_LIMIT;
            agndTrim = ADC_Temp_DecAgndTrim(agndTrim))
        {
            compStatus = ADC_Temp_SetAgndTrim(agndTrim);
            if (0uL == compStatus)
            {
                (void) ADC_Temp_SetAgndTrim(lastAgndTrim);
                break;
            }
            lastAgndTrim = agndTrim;
        }

        return lastAgndTrim;
    }

    /*******************************************************************************
    * Function Name: ADC_Temp_SetOpampAndAgndTrim
    ********************************************************************************
    *
    * Write the Agnd and Opamp trim codes and return the comparator status.
    *
    *******************************************************************************/
    static uint32 ADC_Temp_SetOpampAndAgndTrim(uint32 opampTrim, uint32 agndTrim)
    {
        uint32 trimRegVal = ADC_Temp_UABH_A_OA_TRIM_OA_REG;
        trimRegVal &= ~(ADC_Temp_OPAMP_TRIM_MASK << CyUAB_OA_OFFSET_SHIFT);
        trimRegVal |= (opampTrim << CyUAB_OA_OFFSET_SHIFT);
        ADC_Temp_UABH_A_OA_TRIM_OA_REG = trimRegVal;

        trimRegVal = ADC_Temp_UABH_A_OA_TRIM_AGND_REG;
        trimRegVal &= ~(ADC_Temp_AGND_TRIM_MASK << CyUAB_AGND_OFFSET_SHIFT);
        trimRegVal |= (agndTrim << CyUAB_AGND_OFFSET_SHIFT);
        ADC_Temp_UABH_A_OA_TRIM_AGND_REG = trimRegVal;

        return ADC_Temp_GetCompStatus();
    }

    /*******************************************************************************
    * Function Name: ADC_Temp_SetOpampTrim
    ********************************************************************************
    *
    * Write the Opamp trim code and return the comparator status.
    *
    *******************************************************************************/
    static uint32 ADC_Temp_SetOpampTrim(uint32 opampTrim)
    {
        uint32 trimRegVal = ADC_Temp_UABH_A_OA_TRIM_OA_REG;
        trimRegVal &= ~(ADC_Temp_OPAMP_TRIM_MASK << CyUAB_OA_OFFSET_SHIFT);
        trimRegVal |= (opampTrim << CyUAB_OA_OFFSET_SHIFT);
        ADC_Temp_UABH_A_OA_TRIM_OA_REG = trimRegVal;

        return ADC_Temp_GetCompStatus();
    }


    /*******************************************************************************
    * Function Name: ADC_Temp_SetAgndTrim
    ********************************************************************************
    *
    * Write the Agnd trim code and return the comparator status.
    *
    *******************************************************************************/
    static uint32 ADC_Temp_SetAgndTrim(uint32 agndTrim)
    {
        uint32 trimRegVal = ADC_Temp_UABH_A_OA_TRIM_AGND_REG;
        trimRegVal &= ~(ADC_Temp_AGND_TRIM_MASK << CyUAB_AGND_OFFSET_SHIFT);
        trimRegVal |= (agndTrim << CyUAB_AGND_OFFSET_SHIFT);
        ADC_Temp_UABH_A_OA_TRIM_AGND_REG = trimRegVal;

        return ADC_Temp_GetCompStatus();
    }

    /*******************************************************************************
    * Function Name: ADC_Temp_GetCompStatus
    ********************************************************************************
    *
    * Delays to allow filter to settle before reading the ADC result.
    * Returns 1 if the filter output is greater than AGND, else 0.
    *
    *******************************************************************************/
    static uint32 ADC_Temp_GetCompStatus(void)
    {
        uint32 compStatus = 0UL;
        int16 zeroCode = 0;

        CyDelayUs(ADC_Temp_allConfigs[ADC_Temp_currentConfig].filterTrimDelay);

        /*If unsigned differential */
        if((ADC_Temp_allConfigs[ADC_Temp_currentConfig].sampleCtrl
            & ADC_Temp_SAR_SAMPLE_CTRL_DIFFERENTIAL_SIGNED_MSK) == 0U)
        {
            zeroCode = 0x800;
        }

        if (ADC_Temp_GetResult16(ADC_Temp_FILTER_ADC_CHANNEL) < zeroCode)
        {
            compStatus = 1UL;
        }

        return compStatus;
    }

    /*******************************************************************************
    * Function Name: ADC_Temp_IncOpampTrim
    ********************************************************************************
    *
    * Increments the Opamp trim code by one. Note that Opamp trim code is
    * a 4-bit sign-magnitude value.
    *
    * Skips OPAMP_TRIM_NEG_BASE because it is the same as POS_BASE.
    *
    *******************************************************************************/
    /* Skips OPAMP_TRIM_NEG_BASE because it is the same as POS_BASE. */
    static uint32 ADC_Temp_IncOpampTrim(uint32 trim)
    {

        if (trim < (ADC_Temp_OPAMP_TRIM_POS_LIMIT - 1uL))
        {
            trim = trim + 1uL;
        }
        else if ((ADC_Temp_OPAMP_TRIM_POS_LIMIT - 1uL) == trim)
        {
            trim = ADC_Temp_OPAMP_TRIM_NEG_LIMIT;
        }
        else if (trim <= (ADC_Temp_OPAMP_TRIM_NEG_BASE + 1uL))
        {
            trim = ADC_Temp_OPAMP_TRIM_POS_BASE;
        }
        else
        {
            trim = trim - 1uL;
        }

        return trim;
    }


    /*******************************************************************************
    * Function Name: ADC_Temp_DecOpampTrim
    ********************************************************************************
    *
    * Decrements the Opamp trim code by one. Note that Opamp trim code is
    * a 4-bit sign-magnitude value.
    *
    * Skips OPAMP_TRIM_NEG_BASE because it is the same as POS_BASE.
    *
    *******************************************************************************/
    static uint32 ADC_Temp_DecOpampTrim(uint32 trim)
    {

        if (ADC_Temp_OPAMP_TRIM_POS_BASE == trim)
        {
            trim = ADC_Temp_OPAMP_TRIM_NEG_BASE + 1uL;
        }
        else if (trim < ADC_Temp_OPAMP_TRIM_POS_LIMIT)
        {
            trim = trim - 1uL;
        }
        else if (trim < ADC_Temp_OPAMP_TRIM_NEG_LIMIT)
        {
            trim = trim + 1uL;
        }
        else
        {
            trim = ADC_Temp_OPAMP_TRIM_POS_LIMIT - 1uL;
        }

        return trim;
    }

    /*******************************************************************************
    * Function Name: ADC_Temp_IncAgndTrim
    ********************************************************************************
    *
    * Increments the Agnd trim code by one. Note that Agnd trim code is
    * a 5-bit sign-magnitude value.
    *
    * Skips AGND_TRIM_NEG_BASE because it is the same as POS_BASE.
    *
    *******************************************************************************/
    static uint32 ADC_Temp_IncAgndTrim(uint32 trim)
    {

        if (trim < (ADC_Temp_AGND_TRIM_POS_LIMIT - 1uL))
        {
            trim = trim + 1uL;
        }
        else if ((ADC_Temp_AGND_TRIM_POS_LIMIT - 1uL) == trim)
        {
            trim = ADC_Temp_AGND_TRIM_NEG_LIMIT;
        }
        else if (trim <= (ADC_Temp_AGND_TRIM_NEG_BASE + 1uL))
        {
            trim = ADC_Temp_AGND_TRIM_POS_BASE;
        }
        else
        {
            trim = trim - 1uL;
        }

        return trim;
    }

    /*******************************************************************************
    * Function Name: ADC_Temp_DecAgndTrim
    ********************************************************************************
    *
    * Decrements the Agnd trim code by one. Note that Agnd trim code is
    * a 5-bit sign-magnitude value.
    *
    * Skips AGND_TRIM_NEG_BASE because it is the same as POS_BASE.
    *
    *******************************************************************************/
    static uint32 ADC_Temp_DecAgndTrim(uint32 trim)
    {

        if (trim == ADC_Temp_AGND_TRIM_POS_BASE)
        {
            trim = ADC_Temp_AGND_TRIM_NEG_BASE + 1uL;
        }
        else if (trim < ADC_Temp_AGND_TRIM_POS_LIMIT)
        {
            trim = trim - 1uL;
        }
        else if (trim < ADC_Temp_AGND_TRIM_NEG_LIMIT)
        {
            trim = trim + 1uL;
        }
        else
        {
            trim = ADC_Temp_AGND_TRIM_POS_LIMIT - 1uL;
        }

        return trim;
    }

    /*******************************************************************************
    * Function Name: ADC_Temp_filterInit
    ********************************************************************************
    *
    * Initializes the UAB halves and the CTB buffer between the AGND and the SAR.
    *
    *******************************************************************************/
    void ADC_Temp_filterInit(uint32 configNum)
    {
        /* Configure the common filter settings if any configuration filters */
        switch (configNum)
        {
            #if (0u != ADC_Temp_CFG0_FILTER_PRESENT)
            case 0u:
                ADC_Temp_UABH_A_Init(&ADC_Temp_CFG0_UABH_A_FILTER_config);
                ADC_Temp_UABH_B_Init(&ADC_Temp_CFG0_UABH_B_FILTER_config);
            break;
            #endif
            #if (0u != ADC_Temp_CFG1_FILTER_PRESENT)
            case 1u:
                ADC_Temp_UABH_A_Init(&ADC_Temp_CFG1_UABH_A_FILTER_config);
                ADC_Temp_UABH_B_Init(&ADC_Temp_CFG1_UABH_B_FILTER_config);
            break;
            #endif
            #if (0u != ADC_Temp_CFG2_FILTER_PRESENT)
            case 2u:
                ADC_Temp_UABH_A_Init(&ADC_Temp_CFG2_UABH_A_FILTER_config);
                ADC_Temp_UABH_B_Init(&ADC_Temp_CFG2_UABH_B_FILTER_config);
            break;
            #endif
            #if (0u != ADC_Temp_CFG3_FILTER_PRESENT)
            case 3u:
                ADC_Temp_UABH_A_Init(&ADC_Temp_CFG3_UABH_A_FILTER_config);
                ADC_Temp_UABH_B_Init(&ADC_Temp_CFG3_UABH_B_FILTER_config);
            break;
            #endif
            default:
            break;
        }

        ADC_Temp_FILTERAGND2SAR_BUFFER_Init();
    }
#endif /* ADC_Temp_ANY_CONFIG_USES_FILTER != 0u */


/* ****************************************************************************
* Function Name: ADC_Temp_Init
****************************************************************************//*
*
* \brief Initialize the component according to parameters defined in the
* customizer.
*
* \param None
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/
void ADC_Temp_Init(void)
{
    uint32 chNum = 0ul;
    uint32 configNum = 0u;
    int32 counts;

    if(0u == ADC_Temp_initVar)
    {
        /* Set offset and countsPer10Volt for all channels */
        for(chNum = 0ul; chNum < ADC_Temp_TOTAL_CHANNELS_NUM; chNum++)
        {
            if((ADC_Temp_channelsConfig[chNum] & ADC_Temp_SAR_CHAN_CONFIG_RESOLUTION_MSK) != 0u)
            {
                if((ADC_Temp_allConfigs[configNum].sampleCtrl
                    & ADC_Temp_SAR_SAMPLE_CTRL_SUB_RESOLUTION_MSK)
                    == ADC_Temp_SUB_RESOLUTION_10B)
                {
                    counts = (int32) ADC_Temp_SAR_WRK_MAX_10BIT;
                }
                else
                {
                    counts = (int32) ADC_Temp_SAR_WRK_MAX_8BIT;
                }
            }
            else
            {
               counts = (int32)ADC_Temp_SAR_WRK_MAX_12BIT;
            }

            /* Single Ended Channel */
            if((ADC_Temp_channelsConfig[chNum] & ADC_Temp_SAR_CHAN_CONFIG_DIFFERENTIAL_EN_MSK) == 0u)
            {
                if(((ADC_Temp_allConfigs[configNum].sampleCtrl
                    & ADC_Temp_SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED_MSK)
                    == ADC_Temp_SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED_MSK) &&
                    ((ADC_Temp_allConfigs[configNum].ctrl & ADC_Temp_SAR_CTRL_NEG_SEL_MSK)
                    == ADC_Temp_NEG_VREF_SHIFTED))
                {
                    /* Set offset to the minus half scale to convert results to unsigned format */
                    ADC_Temp_offset[chNum] = (int16)(counts / -2);
                }
                else
                {
                    ADC_Temp_offset[chNum] = 0;
                }

            }
            else    /* Differential channel */
            {
                ADC_Temp_offset[chNum] = 0;
            }

            /* Calculate gain in counts per 10 volts with rounding */
            ADC_Temp_countsPer10Volt[chNum] = (int16)(((counts * ADC_Temp_10MV_COUNTS) \
                            + ADC_Temp_allConfigs[configNum].vrefMvValue) \
                            / (ADC_Temp_allConfigs[configNum].vrefMvValue * 2));

            /* Increment configuration number after rolling over to the next configuration*/
            if((ADC_Temp_allConfigs[configNum].channelBase
                + (ADC_Temp_allConfigs[configNum].numChannels - 1uL)) == chNum)
            {
                configNum++;
            }
        } /* for(chNum = 0ul; chNum < ADC_Temp_TOTAL_CHANNELS_NUM; chNum++) */

        /* Start and set interrupt vector */
        CyIntSetPriority(ADC_Temp_INTC_NUMBER, ADC_Temp_INTC_PRIOR_NUMBER);
        (void)CyIntSetVector(ADC_Temp_INTC_NUMBER, &ADC_Temp_ISR);

        /* Initialize configuration zero if SelectConfig has not been called */
        if(0u == ADC_Temp_selected)
        {
            ADC_Temp_selected = 1u;
            configNum = 0u;
            /* Change Vref selection if is was routed by Creator. Break. */
            #if (ADC_Temp_VREF_ROUTED)
                ADC_Temp_vrefAMux_DisconnectAll();
            #endif
            ADC_Temp_InitConfig(&ADC_Temp_allConfigs[configNum]);
            /* Change Vref selection if is was routed by Creator. Make. */
            #if (ADC_Temp_VREF_ROUTED)
                ADC_Temp_vrefAMux_Select((uint8)configNum);
            #endif
            ADC_Temp_SAR_CHAN_EN_REG = ADC_Temp_allConfigs[configNum].chanEn;
            #if(0u != ADC_Temp_ANY_CONFIG_USES_FILTER)
                ADC_Temp_filterVinMux_Select((uint8)configNum);
                ADC_Temp_filterInit(configNum);
            #endif
        }
    }
    return;
}


/* ****************************************************************************
* Function Name: ADC_Temp_Enable
****************************************************************************//*
*
* \brief Enables the component.
*
* \param None
*
* \return None
*
* \sideeffect
*  None
*
*******************************************************************************/
void ADC_Temp_Enable(void)
{

    #if(0u != ADC_Temp_ANY_CONFIG_USES_FILTER)
        if((ADC_Temp_allConfigs[ADC_Temp_currentConfig].miscConfig
            & ADC_Temp_MISC_CONFIG_FILTER_PRESENT_MSK)
            == ADC_Temp_MISC_CONFIG_FILTER_PRESENT_MSK)
        {
            ADC_Temp_FILTERAGND2SAR_BUFFER_Enable();
            ADC_Temp_UABH_A_Enable();
            ADC_Temp_UABH_B_Enable();
            ADC_Temp_UABH_B_Run(1u);
            ADC_Temp_UABH_A_Run(1u);
        }
    #endif /* ADC_Temp_ANY_CONFIG_USES_FILTER != 0u */

    if (0u == (ADC_Temp_SAR_CTRL_REG & ADC_Temp_SAR_CTRL_ENABLED_MSK))
    {
        while (0u != (ADC_Temp_SAR_STATUS_REG & ADC_Temp_BUSY_MSK))
        {
            /* wait for SAR to go idle to avoid deadlock */
        }

        ADC_Temp_SAR_CTRL_REG |= ADC_Temp_SAR_CTRL_ENABLED_MSK;

        /* The block is ready to use 10 us after the enable signal is set high. */
        CyDelayUs(ADC_Temp_10US_DELAY);
    }

    /* Must set the DFT_CTRL register after enabling the SAR as it is a non-retention register. */
    ADC_Temp_SetDFTControl(&ADC_Temp_allConfigs[ADC_Temp_currentConfig]);

    return;
}


/* [] END OF FILE */
